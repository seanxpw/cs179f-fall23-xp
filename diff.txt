diff --git a/.gitignore b/.gitignore
index fc565fa..f96d18a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -5,6 +5,7 @@ _*
 *.asm
 *.sym
 *.img
+*.pyc
 vectors.S
 bootblock
 entryother
diff --git a/Makefile b/Makefile
index dcaa3dc..5ec0742 100644
--- a/Makefile
+++ b/Makefile
@@ -140,6 +140,11 @@ UPROGS=\
 	$U/_bcachetest\
 	$U/_mounttest\
 	$U/_crashtest\
+	$U/_helloworld\
+	$U/_sleep\
+	$U/_find\
+	$U/_xargs\
+	$U/_test_exec\
 
 fs.img: mkfs/mkfs README user/xargstest.sh $(UPROGS)
 	mkfs/mkfs fs.img README user/xargstest.sh $(UPROGS)
diff --git a/kernel/exec.c b/kernel/exec.c
index 614f7ca..073d1b4 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -12,6 +12,7 @@ static int loadseg(pde_t *pgdir, uint64 addr, struct inode *ip, uint offset, uin
 int
 exec(char *path, char **argv)
 {
+  // printf("start exec\n");
   char *s, *last;
   int i, off;
   uint64 argc, sz, sp, ustack[MAXARG+1], stackbase;
@@ -25,8 +26,9 @@ exec(char *path, char **argv)
 
   if((ip = namei(path)) == 0){
     end_op(ROOTDEV);
-    return -1;
+    return -2;
   }
+  
   ilock(ip);
 
   // Check ELF header
@@ -38,6 +40,8 @@ exec(char *path, char **argv)
   if((pagetable = proc_pagetable(p)) == 0)
     goto bad;
 
+  // printf("good1\n");
+
   // Load program into memory.
   sz = 0;
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
@@ -47,6 +51,8 @@ exec(char *path, char **argv)
       continue;
     if(ph.memsz < ph.filesz)
       goto bad;
+
+    // printf("good2\n");  
     if(ph.vaddr + ph.memsz < ph.vaddr)
       goto bad;
     if((sz = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0)
@@ -60,6 +66,8 @@ exec(char *path, char **argv)
   end_op(ROOTDEV);
   ip = 0;
 
+      // printf("good3\n"); 
+
   p = myproc();
   uint64 oldsz = p->sz;
 
@@ -71,9 +79,11 @@ exec(char *path, char **argv)
   uvmclear(pagetable, sz-2*PGSIZE);
   sp = sz;
   stackbase = sp - PGSIZE;
-
+      // printf("good4\n"); 
   // Push argument strings, prepare rest of stack in ustack.
-  for(argc = 0; argv[argc]; argc++) {
+  for(argc = 0; argv[argc]; argc++) 
+  {
+    // printf("in loop argc=%d\n",argc);
     if(argc >= MAXARG)
       goto bad;
     sp -= strlen(argv[argc]) + 1;
@@ -86,6 +96,8 @@ exec(char *path, char **argv)
   }
   ustack[argc] = 0;
 
+  // printf("good5\n"); 
+
   // push the array of argv[] pointers.
   sp -= (argc+1) * sizeof(uint64);
   sp -= sp % 16;
@@ -93,7 +105,7 @@ exec(char *path, char **argv)
     goto bad;
   if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
     goto bad;
-
+  // printf("good6\n"); 
   // arguments to user main(argc, argv)
   // argc is returned via the system call return
   // value, which goes in a0.
@@ -104,7 +116,7 @@ exec(char *path, char **argv)
     if(*s == '/')
       last = s+1;
   safestrcpy(p->name, last, sizeof(p->name));
-    
+      // printf("good7\n"); 
   // Commit to the user image.
   oldpagetable = p->pagetable;
   p->pagetable = pagetable;
@@ -112,16 +124,18 @@ exec(char *path, char **argv)
   p->tf->epc = elf.entry;  // initial program counter = main
   p->tf->sp = sp; // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
+  // printf("argc = %d",argc);
   return argc; // this ends up in a0, the first argument to main(argc, argv)
 
  bad:
+//  printf("bad\n");
   if(pagetable)
     proc_freepagetable(pagetable, sz);
   if(ip){
     iunlockput(ip);
     end_op(ROOTDEV);
   }
-  return -1;
+  return -10;
 }
 
 // Load a program segment into pagetable at virtual address va.
@@ -146,7 +160,14 @@ loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz
     else
       n = PGSIZE;
     if(readi(ip, 0, (uint64)pa, offset+i, n) != n)
+    {
+      
+      // printf("\n");
       return -1;
+
+    }
+
+      
   }
   
   return 0;
diff --git a/user/ls.c b/user/ls.c
index 5847555..fa4d19f 100644
--- a/user/ls.c
+++ b/user/ls.c
@@ -44,6 +44,7 @@ ls(char *path)
   switch(st.type){
   case T_FILE:
     printf("%s %d %d %l\n", fmtname(path), st.type, st.ino, st.size);
+    //fmtname(path) returns the pure name of the file.
     break;
 
   case T_DIR:
@@ -52,8 +53,8 @@ ls(char *path)
       break;
     }
     strcpy(buf, path);
-    p = buf+strlen(buf);
-    *p++ = '/';
+    p = buf+strlen(buf); // now p points '\0' at the end of buf
+    *p++ = '/'; // '\0' becomes '/', then point to the next
     while(read(fd, &de, sizeof(de)) == sizeof(de)){
       if(de.inum == 0)
         continue;
diff --git a/user/sh.c b/user/sh.c
index dde17be..d29c607 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -149,15 +149,16 @@ main(void)
   int fd;
 
   // Ensure that three file descriptors are open.
-  while((fd = open("console", O_RDWR)) >= 0){
+  while((fd = open("console", O_RDWR)) >= 0){ // O_RDWR: Open for reading and writing
     if(fd >= 3){
       close(fd);
-      break;
+      break; // if the fd>=3, it means the 0, 1, 2 is opened.
     }
   }
+  // When the loop finishes, file descriptors 0 to 2 (stdin, stdout and stderr) are guaranteed to be open.
 
   // Read and run input commands.
-  while(getcmd(buf, sizeof(buf)) >= 0){
+  while(getcmd(buf, sizeof(buf)) >= 0){ // Why >= but not ==
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
       // Chdir must be called by the parent, not the child.
       buf[strlen(buf)-1] = 0;  // chop \n
diff --git a/user/ulib.c b/user/ulib.c
index ddda0f5..e1be04b 100644
--- a/user/ulib.c
+++ b/user/ulib.c
@@ -3,6 +3,7 @@
 #include "kernel/fcntl.h"
 #include "user/user.h"
 
+// strcpy(char *s, const char *t), copy t to s
 char*
 strcpy(char *s, const char *t)
 {
@@ -22,8 +23,7 @@ strcmp(const char *p, const char *q)
   return (uchar)*p - (uchar)*q;
 }
 
-uint
-strlen(const char *s)
+uint strlen(const char *s)
 {
   int n;
 
diff --git a/user/user.h b/user/user.h
index e7b6a22..c15233c 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,3 +1,4 @@
+
 struct stat;
 struct rtcdate;
 
